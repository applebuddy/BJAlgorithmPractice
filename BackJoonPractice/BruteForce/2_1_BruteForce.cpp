////
////  BruteForce.cpp
////  BackJoonPractice
////
////  Created by Min Kyeong Tae on 19/04/2019.
////  Copyright © 2019 Min Kyeong Tae. All rights reserved.
////
//// MARK:- Brute Force : 브루트 포스는 모든 경우의 수를 다 해보는 것이다.
////                      ex) 4자리비밀번호의해독, (0000~9999), 경우의 수는 10,000가지이다.
//// * 브루트 포스는 모든 경우의 수를 다 해보는 것이다. 이 때, 경우의 수를 다 해보는데 걸리는 시간이 문제의 시간제한을 넘지 않아야한다.
//
//// 1. 문제의 가능한 경우의 수를 계산해본다. * 직접계산을 통해 구한다. 대부분 손으로 계산해볼 수 있다.
//// 2. 가능한 모든 방법을 다 만들어본다. *하나도 빠짐없이 만들어야한다., for문사용, 순열사용, 재귀호출, 비트마스크 등...
//// 3. 각각의 방법을 이용해 답을 구해본다.
//// * 각각의 방식을 사용해 보자.(for문사용, 순열사용, 재귀호출, 비트마스크 등...)
//// *
//
//
//
//#include <iostream>
//#include <algorithm>
//using namespace std;
//
//
//// MARK: 2309_일곱 난쟁이 문제 : 9명의 난쟁이 중 일곱명의 난쟁이를 찾는 문제, 일곱난쟁이의 키 합은 100이다.
//// * 9명 중 7명을 고른다.(9명 중 2명을 고른다. 와 같다.)
//
//// ★풀이법 : 두명의 난쟁이의 키를 순차적으로 빼보며 나머지 7명의 키가 100이 될때를 탐색한다.
////          7명을 찾게 되면 가짜난쟁이놈들 두명을 제외한 난쟁이들의 키를 출력한다.
////
////int main() {
////
////    // 9명의 난쟁이 키를 입력해본다.
////    int kobimon[9] = {0,};
////    int sumValue = 0;
////    for(int i=0; i<9; i++){
////        scanf("%d",&kobimon[i]);
////        sumValue += kobimon[i];
////    }
////    sort(kobimon, kobimon+9); // 오름차순으로 정렬이기
////
////    // ★ 일곱난쟁이 알고리즘 복잡도는 N^2 이다.
////    for(int i=0; i<9; i++){
////        for(int j=i+1; j<9; j++){
////            if(sumValue - kobimon[i] - kobimon[j] == 100) {
////                // 가짜난쟁이놈들 두명을 제외해서 키의 합 100이 확인되면 그 즉시 오름차순으로 정렬된 진짜 난쟁이들의 키를 출력하고 종료한다.
////                for(int k=0; k<9; k++){
////                    if((k==i)||(k==j)){
////                        continue;
////                    }
////
////                    cout << kobimon[k] << '\n';
////                }
////
////                return 0;
////            }
////        }
////    }
////
////    // 9명의 난쟁이 중 2명의 난쟁이를 뺀
////    return 0;
////}
//
//
//// MARK: 1476_날짜 계산
//// ♠︎ 준규가 사는 나라는 우리가 사용하는 연도와 다른 방식을 이용한다. 준규가 사는 나라에서는 수 3개를 이용해서 연도를 나타낸다. 각각의 수는 지구, 태양, 그리고 달을 나타낸다.
//
////지구를 나타내는 수를 E, 태양을 나타내는 수를 S, 달을 나타내는 수를 M이라고 했을 때, 이 세 수는 서로 다른 범위를 가진다. (1 ≤ E ≤ 15, 1 ≤ S ≤ 28, 1 ≤ M ≤ 19)
//
////우리가 알고있는 1년은 준규가 살고있는 나라에서는 1 1 1로 나타낼 수 있다. 1년이 지날 때마다, 세 수는 모두 1씩 증가한다. 만약, 어떤 수가 범위를 넘어가는 경우에는 1이 된다.
//
////예를 들어, 15년은 15 15 15로 나타낼 수 있다. 하지만, 1년이 지나서 16년이 지나면 16 16 16이 아니라 1 16 16이 된다. 이유는 1 ≤ E ≤ 15 라서 범위를 넘어가기 때문이다.
//
////E, S, M이 주어졌고, 1년이 준규가 사는 나라에서 1 1 1일때, 준규가 사는 나라에서 E S M이 우리가 알고 있는 연도로 몇 년인지 구하는 프로그램을 작성하시오.
//
//int main() {
//    
//    // 연도표시에 사용되는 E S M
//    int e=1,s=1,m=1;
//    // 대응되는 연도값을 찾아야하는 E S M
//    int E=0,S=0,M=0;
//    int year=1;
//    
//    scanf("%d %d %d",&E, &S, &M); // E S M을 입력받는다. 각각 1~15, 28, 19의 범위를 가진다.
//    
//    while(1){
//        
//        // 1 1 1부터 시작해서 일치안하면
//        if((e==E)&&(s==S)&&(m==M)){
//            cout << year;
//            return 0;
//        } else {
//            // e,s,m을 1씩 증가 AND 연도를 ++시키고 다음으로 넘어간다.
//            e++; if(e>15) e=1;
//            s++; if(s>28) s=1;
//            m++; if(m>19) m=1;
//            year++;
//        }
//    }
//}
//
//// MARK: 14500_테트로미노 (작성해야 할 코드가 길어 시간 상 일단 보류)
